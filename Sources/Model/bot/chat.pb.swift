// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chat.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Bot_ChatFlag: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case none // = 0
  case login // = 1
  case logout // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .login
    case 2: self = .logout
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .login: return 1
    case .logout: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bot_ChatFlag: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bot_ChatFlag] = [
    .none,
    .login,
    .logout,
  ]
}

#endif  // swift(>=4.2)

public enum Bot_ChatHistoryDirection: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case send // = 0
  case receive // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .send
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .send
    case 1: self = .receive
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .send: return 0
    case .receive: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bot_ChatHistoryDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bot_ChatHistoryDirection] = [
    .send,
    .receive,
  ]
}

#endif  // swift(>=4.2)

public struct Bot_SourceMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pdfNumpages: String = String()

  public var source: String = String()

  public var summrize: String = String()

  public var title: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bot_SourceDocs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pageContent: String = String()

  public var metadata: Bot_SourceMeta {
    get {return _metadata ?? Bot_SourceMeta()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Bot_SourceMeta? = nil
}

public struct Bot_InformationSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var docs: [Bot_SourceDocs] = []

  public var chatID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bot_ChatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var question: String = String()

  public var history: [String] = []

  public var qaPrompt: String = String()

  public var temperature: Double = 0

  public var uid: String = String()

  public var flag: Bot_ChatFlag = .none

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bot_ChatResponseChatID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bot_ChatResponseTextDelta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bot_ChatResponseThinkingStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bot_ChatResponseAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bot_ChatResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Sys_APIStatus {
    get {return _status ?? Sys_APIStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var resp: Bot_ChatResponse.OneOf_Resp? = nil

  public var chatID: Bot_ChatResponseChatID {
    get {
      if case .chatID(let v)? = resp {return v}
      return Bot_ChatResponseChatID()
    }
    set {resp = .chatID(newValue)}
  }

  public var textDelta: Bot_ChatResponseTextDelta {
    get {
      if case .textDelta(let v)? = resp {return v}
      return Bot_ChatResponseTextDelta()
    }
    set {resp = .textDelta(newValue)}
  }

  public var materialSource: Bot_InformationSource {
    get {
      if case .materialSource(let v)? = resp {return v}
      return Bot_InformationSource()
    }
    set {resp = .materialSource(newValue)}
  }

  public var thinkingStatus: Bot_ChatResponseThinkingStatus {
    get {
      if case .thinkingStatus(let v)? = resp {return v}
      return Bot_ChatResponseThinkingStatus()
    }
    set {resp = .thinkingStatus(newValue)}
  }

  public var action: Bot_ChatResponseAction {
    get {
      if case .action(let v)? = resp {return v}
      return Bot_ChatResponseAction()
    }
    set {resp = .action(newValue)}
  }

  public var done: Bot_ChatResponseDone {
    get {
      if case .done(let v)? = resp {return v}
      return Bot_ChatResponseDone()
    }
    set {resp = .done(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Resp: Equatable {
    case chatID(Bot_ChatResponseChatID)
    case textDelta(Bot_ChatResponseTextDelta)
    case materialSource(Bot_InformationSource)
    case thinkingStatus(Bot_ChatResponseThinkingStatus)
    case action(Bot_ChatResponseAction)
    case done(Bot_ChatResponseDone)

  #if !swift(>=4.1)
    public static func ==(lhs: Bot_ChatResponse.OneOf_Resp, rhs: Bot_ChatResponse.OneOf_Resp) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.chatID, .chatID): return {
        guard case .chatID(let l) = lhs, case .chatID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.textDelta, .textDelta): return {
        guard case .textDelta(let l) = lhs, case .textDelta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.materialSource, .materialSource): return {
        guard case .materialSource(let l) = lhs, case .materialSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.thinkingStatus, .thinkingStatus): return {
        guard case .thinkingStatus(let l) = lhs, case .thinkingStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.action, .action): return {
        guard case .action(let l) = lhs, case .action(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.done, .done): return {
        guard case .done(let l) = lhs, case .done(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _status: Sys_APIStatus? = nil
}

public struct Bot_ChatResponseDone {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bot_ChatPingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var length: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bot_FeedBackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: String = String()

  public var uid: String = String()

  public var starts: Int32 = 0

  public var reason: String = String()

  public var betterAnswer: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bot_Notify {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bot_GetNotifyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Sys_APIStatus {
    get {return _status ?? Sys_APIStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var notify: [Bot_Notify] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Sys_APIStatus? = nil
}

public struct Bot_GetNotifyByUIDRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bot_ChatHistory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var direction: Bot_ChatHistoryDirection = .send

  public var content: String = String()

  public var ts: Int64 = 0

  public var chatMetaInfo: Bot_InformationSource {
    get {return _chatMetaInfo ?? Bot_InformationSource()}
    set {_chatMetaInfo = newValue}
  }
  /// Returns true if `chatMetaInfo` has been explicitly set.
  public var hasChatMetaInfo: Bool {return self._chatMetaInfo != nil}
  /// Clears the value of `chatMetaInfo`. Subsequent reads from it will return its default value.
  public mutating func clearChatMetaInfo() {self._chatMetaInfo = nil}

  public var chatID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatMetaInfo: Bot_InformationSource? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Bot_ChatFlag: @unchecked Sendable {}
extension Bot_ChatHistoryDirection: @unchecked Sendable {}
extension Bot_SourceMeta: @unchecked Sendable {}
extension Bot_SourceDocs: @unchecked Sendable {}
extension Bot_InformationSource: @unchecked Sendable {}
extension Bot_ChatRequest: @unchecked Sendable {}
extension Bot_ChatResponseChatID: @unchecked Sendable {}
extension Bot_ChatResponseTextDelta: @unchecked Sendable {}
extension Bot_ChatResponseThinkingStatus: @unchecked Sendable {}
extension Bot_ChatResponseAction: @unchecked Sendable {}
extension Bot_ChatResponse: @unchecked Sendable {}
extension Bot_ChatResponse.OneOf_Resp: @unchecked Sendable {}
extension Bot_ChatResponseDone: @unchecked Sendable {}
extension Bot_ChatPingRequest: @unchecked Sendable {}
extension Bot_FeedBackRequest: @unchecked Sendable {}
extension Bot_Notify: @unchecked Sendable {}
extension Bot_GetNotifyResponse: @unchecked Sendable {}
extension Bot_GetNotifyByUIDRequest: @unchecked Sendable {}
extension Bot_ChatHistory: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bot"

extension Bot_ChatFlag: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "Login"),
    2: .same(proto: "Logout"),
  ]
}

extension Bot_ChatHistoryDirection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Send"),
    1: .same(proto: "Receive"),
  ]
}

extension Bot_SourceMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SourceMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pdf_numpages"),
    2: .same(proto: "source"),
    3: .same(proto: "summrize"),
    4: .same(proto: "title"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pdfNumpages) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.summrize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.title) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pdfNumpages.isEmpty {
      try visitor.visitSingularStringField(value: self.pdfNumpages, fieldNumber: 1)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 2)
    }
    if !self.summrize.isEmpty {
      try visitor.visitSingularStringField(value: self.summrize, fieldNumber: 3)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_SourceMeta, rhs: Bot_SourceMeta) -> Bool {
    if lhs.pdfNumpages != rhs.pdfNumpages {return false}
    if lhs.source != rhs.source {return false}
    if lhs.summrize != rhs.summrize {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bot_SourceDocs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SourceDocs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pageContent"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pageContent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pageContent.isEmpty {
      try visitor.visitSingularStringField(value: self.pageContent, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_SourceDocs, rhs: Bot_SourceDocs) -> Bool {
    if lhs.pageContent != rhs.pageContent {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bot_InformationSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InformationSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "docs"),
    2: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.docs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.docs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.docs, fieldNumber: 1)
    }
    if !self.chatID.isEmpty {
      try visitor.visitSingularStringField(value: self.chatID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_InformationSource, rhs: Bot_InformationSource) -> Bool {
    if lhs.docs != rhs.docs {return false}
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bot_ChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "question"),
    2: .same(proto: "history"),
    3: .standard(proto: "qa_prompt"),
    4: .same(proto: "temperature"),
    5: .same(proto: "uid"),
    6: .same(proto: "flag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.question) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.history) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.qaPrompt) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.temperature) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.flag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.question.isEmpty {
      try visitor.visitSingularStringField(value: self.question, fieldNumber: 1)
    }
    if !self.history.isEmpty {
      try visitor.visitRepeatedStringField(value: self.history, fieldNumber: 2)
    }
    if !self.qaPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.qaPrompt, fieldNumber: 3)
    }
    if self.temperature != 0 {
      try visitor.visitSingularDoubleField(value: self.temperature, fieldNumber: 4)
    }
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 5)
    }
    if self.flag != .none {
      try visitor.visitSingularEnumField(value: self.flag, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_ChatRequest, rhs: Bot_ChatRequest) -> Bool {
    if lhs.question != rhs.question {return false}
    if lhs.history != rhs.history {return false}
    if lhs.qaPrompt != rhs.qaPrompt {return false}
    if lhs.temperature != rhs.temperature {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.flag != rhs.flag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bot_ChatResponseChatID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatResponseChatID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chatID.isEmpty {
      try visitor.visitSingularStringField(value: self.chatID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_ChatResponseChatID, rhs: Bot_ChatResponseChatID) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bot_ChatResponseTextDelta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatResponseTextDelta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_ChatResponseTextDelta, rhs: Bot_ChatResponseTextDelta) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bot_ChatResponseThinkingStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatResponseThinkingStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_ChatResponseThinkingStatus, rhs: Bot_ChatResponseThinkingStatus) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bot_ChatResponseAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatResponseAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_ChatResponseAction, rhs: Bot_ChatResponseAction) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bot_ChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "chat_id"),
    3: .standard(proto: "text_delta"),
    4: .standard(proto: "material_source"),
    5: .standard(proto: "thinking_status"),
    6: .same(proto: "action"),
    7: .same(proto: "done"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try {
        var v: Bot_ChatResponseChatID?
        var hadOneofValue = false
        if let current = self.resp {
          hadOneofValue = true
          if case .chatID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resp = .chatID(v)
        }
      }()
      case 3: try {
        var v: Bot_ChatResponseTextDelta?
        var hadOneofValue = false
        if let current = self.resp {
          hadOneofValue = true
          if case .textDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resp = .textDelta(v)
        }
      }()
      case 4: try {
        var v: Bot_InformationSource?
        var hadOneofValue = false
        if let current = self.resp {
          hadOneofValue = true
          if case .materialSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resp = .materialSource(v)
        }
      }()
      case 5: try {
        var v: Bot_ChatResponseThinkingStatus?
        var hadOneofValue = false
        if let current = self.resp {
          hadOneofValue = true
          if case .thinkingStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resp = .thinkingStatus(v)
        }
      }()
      case 6: try {
        var v: Bot_ChatResponseAction?
        var hadOneofValue = false
        if let current = self.resp {
          hadOneofValue = true
          if case .action(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resp = .action(v)
        }
      }()
      case 7: try {
        var v: Bot_ChatResponseDone?
        var hadOneofValue = false
        if let current = self.resp {
          hadOneofValue = true
          if case .done(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resp = .done(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.resp {
    case .chatID?: try {
      guard case .chatID(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .textDelta?: try {
      guard case .textDelta(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .materialSource?: try {
      guard case .materialSource(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .thinkingStatus?: try {
      guard case .thinkingStatus(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .action?: try {
      guard case .action(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .done?: try {
      guard case .done(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_ChatResponse, rhs: Bot_ChatResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.resp != rhs.resp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bot_ChatResponseDone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatResponseDone"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_ChatResponseDone, rhs: Bot_ChatResponseDone) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bot_ChatPingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatPingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.length) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.length != 0 {
      try visitor.visitSingularInt32Field(value: self.length, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_ChatPingRequest, rhs: Bot_ChatPingRequest) -> Bool {
    if lhs.length != rhs.length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bot_FeedBackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeedBackRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "uid"),
    3: .same(proto: "starts"),
    4: .same(proto: "reason"),
    5: .standard(proto: "better_answer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.starts) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.betterAnswer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chatID.isEmpty {
      try visitor.visitSingularStringField(value: self.chatID, fieldNumber: 1)
    }
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 2)
    }
    if self.starts != 0 {
      try visitor.visitSingularInt32Field(value: self.starts, fieldNumber: 3)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 4)
    }
    if !self.betterAnswer.isEmpty {
      try visitor.visitSingularStringField(value: self.betterAnswer, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_FeedBackRequest, rhs: Bot_FeedBackRequest) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.starts != rhs.starts {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.betterAnswer != rhs.betterAnswer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bot_Notify: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Notify"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_Notify, rhs: Bot_Notify) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bot_GetNotifyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNotifyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "notify"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.notify) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.notify.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notify, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_GetNotifyResponse, rhs: Bot_GetNotifyResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.notify != rhs.notify {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bot_GetNotifyByUIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNotifyByUIDRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_GetNotifyByUIDRequest, rhs: Bot_GetNotifyByUIDRequest) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bot_ChatHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatHistory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "direction"),
    3: .same(proto: "content"),
    4: .same(proto: "ts"),
    5: .standard(proto: "chat_meta_info"),
    6: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.ts) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._chatMetaInfo) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.direction != .send {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    if self.ts != 0 {
      try visitor.visitSingularInt64Field(value: self.ts, fieldNumber: 4)
    }
    try { if let v = self._chatMetaInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.chatID.isEmpty {
      try visitor.visitSingularStringField(value: self.chatID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bot_ChatHistory, rhs: Bot_ChatHistory) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.content != rhs.content {return false}
    if lhs.ts != rhs.ts {return false}
    if lhs._chatMetaInfo != rhs._chatMetaInfo {return false}
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
